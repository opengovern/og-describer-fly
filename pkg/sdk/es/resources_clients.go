// Code is generated by go generate. DO NOT EDIT.
package opengovernance

import (
	"context"
	fly "github.com/opengovern/og-describer-fly/provider/model"
	essdk "github.com/opengovern/og-util/pkg/opengovernance-es-sdk"
	steampipesdk "github.com/opengovern/og-util/pkg/steampipe"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"runtime"
)

type Client struct {
	essdk.Client
}

// ==========================  START: App =============================

type App struct {
	ResourceID      string             `json:"resource_id"`
	PlatformID      string             `json:"platform_id"`
	Description     fly.AppDescription `json:"Description"`
	Metadata        fly.Metadata       `json:"metadata"`
	DescribedBy     string             `json:"described_by"`
	ResourceType    string             `json:"resource_type"`
	IntegrationType string             `json:"integration_type"`
	IntegrationID   string             `json:"integration_id"`
}

type AppHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  App           `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AppHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AppHit          `json:"hits"`
}

type AppSearchResponse struct {
	PitID string  `json:"pit_id"`
	Hits  AppHits `json:"hits"`
}

type AppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppPaginator(filters []essdk.BoolFilter, limit *int64) (AppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "fly_app", filters, limit)
	if err != nil {
		return AppPaginator{}, err
	}

	p := AppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AppPaginator) NextPage(ctx context.Context) ([]App, error) {
	var response AppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []App
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppFilters = map[string]string{
	"id":            "Description.ID",
	"machine_count": "Description.MachineCount",
	"name":          "Description.Name",
	"network":       "Description.Network",
}

func ListApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApp")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApp NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApp NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApp GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAppFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApp NewAppPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApp paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAppFilters = map[string]string{
	"id":            "Description.ID",
	"machine_count": "Description.MachineCount",
	"name":          "Description.Name",
	"network":       "Description.Network",
}

func GetApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApp")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAppPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAppFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: App =============================

// ==========================  START: Machine =============================

type Machine struct {
	ResourceID      string                 `json:"resource_id"`
	PlatformID      string                 `json:"platform_id"`
	Description     fly.MachineDescription `json:"Description"`
	Metadata        fly.Metadata           `json:"metadata"`
	DescribedBy     string                 `json:"described_by"`
	ResourceType    string                 `json:"resource_type"`
	IntegrationType string                 `json:"integration_type"`
	IntegrationID   string                 `json:"integration_id"`
}

type MachineHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Machine       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type MachineHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []MachineHit      `json:"hits"`
}

type MachineSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  MachineHits `json:"hits"`
}

type MachinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMachinePaginator(filters []essdk.BoolFilter, limit *int64) (MachinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "fly_machine", filters, limit)
	if err != nil {
		return MachinePaginator{}, err
	}

	p := MachinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MachinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MachinePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p MachinePaginator) NextPage(ctx context.Context) ([]Machine, error) {
	var response MachineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Machine
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMachineFilters = map[string]string{
	"checks":            "Description.Checks",
	"config":            "Description.Config",
	"created_at":        "Description.CreatedAt",
	"events":            "Description.Events",
	"host_status":       "Description.HostStatus",
	"id":                "Description.ID",
	"image_ref":         "Description.ImageRef",
	"incomplete_config": "Description.IncompleteConfig",
	"instance_id":       "Description.InstanceID",
	"name":              "Description.Name",
	"nonce":             "Description.Nonce",
	"private_ip":        "Description.PrivateIP",
	"region":            "Description.Region",
	"state":             "Description.State",
	"updated_at":        "Description.UpdatedAt",
}

func ListMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMachine")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListMachine NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListMachine NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListMachine GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewMachinePaginator(essdk.BuildFilter(ctx, d.QueryContext, listMachineFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListMachine NewMachinePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListMachine paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getMachineFilters = map[string]string{
	"checks":            "Description.Checks",
	"config":            "Description.Config",
	"created_at":        "Description.CreatedAt",
	"events":            "Description.Events",
	"host_status":       "Description.HostStatus",
	"id":                "Description.ID",
	"image_ref":         "Description.ImageRef",
	"incomplete_config": "Description.IncompleteConfig",
	"instance_id":       "Description.InstanceID",
	"name":              "Description.Name",
	"nonce":             "Description.Nonce",
	"private_ip":        "Description.PrivateIP",
	"region":            "Description.Region",
	"state":             "Description.State",
	"updated_at":        "Description.UpdatedAt",
}

func GetMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMachine")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewMachinePaginator(essdk.BuildFilter(ctx, d.QueryContext, getMachineFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Machine =============================

// ==========================  START: Volume =============================

type Volume struct {
	ResourceID      string                `json:"resource_id"`
	PlatformID      string                `json:"platform_id"`
	Description     fly.VolumeDescription `json:"Description"`
	Metadata        fly.Metadata          `json:"metadata"`
	DescribedBy     string                `json:"described_by"`
	ResourceType    string                `json:"resource_type"`
	IntegrationType string                `json:"integration_type"`
	IntegrationID   string                `json:"integration_id"`
}

type VolumeHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Volume        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VolumeHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VolumeHit       `json:"hits"`
}

type VolumeSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  VolumeHits `json:"hits"`
}

type VolumePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVolumePaginator(filters []essdk.BoolFilter, limit *int64) (VolumePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "fly_volume", filters, limit)
	if err != nil {
		return VolumePaginator{}, err
	}

	p := VolumePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VolumePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VolumePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p VolumePaginator) NextPage(ctx context.Context) ([]Volume, error) {
	var response VolumeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Volume
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVolumeFilters = map[string]string{
	"attached_alloc_id":   "Description.AttachedAllocID",
	"attached_machine_id": "Description.AttachedMachineID",
	"auto_backup_enabled": "Description.AutoBackupEnabled",
	"block_size":          "Description.BlockSize",
	"blocks":              "Description.Blocks",
	"blocks_avail":        "Description.BlocksAvail",
	"blocks_free":         "Description.BlocksFree",
	"created_at":          "Description.CreatedAt",
	"encrypted":           "Description.Encrypted",
	"fstype":              "Description.FSType",
	"host_status":         "Description.HostStatus",
	"id":                  "Description.ID",
	"name":                "Description.Name",
	"region":              "Description.Region",
	"size_gb":             "Description.SizeGB",
	"snapshot_retention":  "Description.SnapshotRetention",
	"state":               "Description.State",
	"zone":                "Description.Zone",
}

func ListVolume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVolume")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewVolumePaginator(essdk.BuildFilter(ctx, d.QueryContext, listVolumeFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListVolume NewVolumePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListVolume paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getVolumeFilters = map[string]string{
	"attached_alloc_id":   "Description.AttachedAllocID",
	"attached_machine_id": "Description.AttachedMachineID",
	"auto_backup_enabled": "Description.AutoBackupEnabled",
	"block_size":          "Description.BlockSize",
	"blocks":              "Description.Blocks",
	"blocks_avail":        "Description.BlocksAvail",
	"blocks_free":         "Description.BlocksFree",
	"created_at":          "Description.CreatedAt",
	"encrypted":           "Description.Encrypted",
	"fstype":              "Description.FSType",
	"host_status":         "Description.HostStatus",
	"id":                  "Description.ID",
	"name":                "Description.Name",
	"region":              "Description.Region",
	"size_gb":             "Description.SizeGB",
	"snapshot_retention":  "Description.SnapshotRetention",
	"state":               "Description.State",
	"zone":                "Description.Zone",
}

func GetVolume(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVolume")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewVolumePaginator(essdk.BuildFilter(ctx, d.QueryContext, getVolumeFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Volume =============================

// ==========================  START: Secret =============================

type Secret struct {
	ResourceID      string                `json:"resource_id"`
	PlatformID      string                `json:"platform_id"`
	Description     fly.SecretDescription `json:"Description"`
	Metadata        fly.Metadata          `json:"metadata"`
	DescribedBy     string                `json:"described_by"`
	ResourceType    string                `json:"resource_type"`
	IntegrationType string                `json:"integration_type"`
	IntegrationID   string                `json:"integration_id"`
}

type SecretHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Secret        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SecretHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SecretHit       `json:"hits"`
}

type SecretSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  SecretHits `json:"hits"`
}

type SecretPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecretPaginator(filters []essdk.BoolFilter, limit *int64) (SecretPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "fly_secret", filters, limit)
	if err != nil {
		return SecretPaginator{}, err
	}

	p := SecretPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecretPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecretPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p SecretPaginator) NextPage(ctx context.Context) ([]Secret, error) {
	var response SecretSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Secret
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecretFilters = map[string]string{
	"label":      "Description.Label",
	"public_key": "Description.PublicKey",
	"type":       "Description.Type",
}

func ListSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecret")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewSecretPaginator(essdk.BuildFilter(ctx, d.QueryContext, listSecretFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListSecret NewSecretPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListSecret paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getSecretFilters = map[string]string{
	"label":      "Description.Label",
	"public_key": "Description.PublicKey",
	"type":       "Description.Type",
}

func GetSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecret")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewSecretPaginator(essdk.BuildFilter(ctx, d.QueryContext, getSecretFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Secret =============================
